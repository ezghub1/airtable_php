<?php
/**
 * WebhooksSpecificationFilters
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  Ez128\Airtable
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Airtable API
 *
 * The Airtable REST API. Please see https://airtable.com/developers/ for more details.
 *
 * The version of the OpenAPI document: 0
 * Contact: help@airtable.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Ez128\Airtable\Model;

use \ArrayAccess;
use \Ez128\Airtable\ObjectSerializer;

/**
 * WebhooksSpecificationFilters Class Doc Comment
 *
 * @category Class
 * @description A webhook specification can contain a filters object. For example, the specification for a webhook watching the data in a table is as follows: &#x60;&#x60;&#x60; {   \&quot;options\&quot;: {     \&quot;filters\&quot;: {       \&quot;dataTypes\&quot;: [         \&quot;tableData\&quot;       ],       \&quot;recordChangeScope\&quot;: \&quot;tbl00000000000000\&quot;     }   } } &#x60;&#x60;&#x60; The table events can be filtered down even more to cover just record data changes for certain fields from specific sources. &#x60;&#x60;&#x60; {   \&quot;options\&quot;: {     \&quot;filters\&quot;: {       \&quot;fromSources\&quot;: [         \&quot;client\&quot;       ],       \&quot;dataTypes\&quot;: [         \&quot;tableData\&quot;       ],       \&quot;recordChangeScope\&quot;: \&quot;tbl00000000000000\&quot;,       \&quot;watchDataInFieldIds\&quot;: [         \&quot;fld00000000000000\&quot;,         \&quot;fld00000000000001\&quot;,         \&quot;fld00000000000002\&quot;       ]     }   } } &#x60;&#x60;&#x60;  Aside from dataTypes, the keys in a filters object are optional. By default, a webhook will generate payloads across an entire base according to the specified dataTypes. We strongly recommend that your integration specify a filters object with a subset of the filter keys to ensure that your integration is notified for only the most relevant events.
 * @package  Ez128\Airtable
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class WebhooksSpecificationFilters implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Webhooks_specification_filters';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'change_types' => 'string[]',
        'data_types' => 'string[]',
        'from_sources' => 'string[]',
        'record_change_scope' => 'string',
        'source_options' => '\Ez128\Airtable\Model\WebhooksSpecificationFiltersSourceOptions',
        'watch_data_in_field_ids' => 'string[]',
        'watch_schemas_of_field_ids' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'change_types' => null,
        'data_types' => null,
        'from_sources' => null,
        'record_change_scope' => null,
        'source_options' => null,
        'watch_data_in_field_ids' => null,
        'watch_schemas_of_field_ids' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'change_types' => false,
        'data_types' => false,
        'from_sources' => false,
        'record_change_scope' => false,
        'source_options' => false,
        'watch_data_in_field_ids' => false,
        'watch_schemas_of_field_ids' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'change_types' => 'changeTypes',
        'data_types' => 'dataTypes',
        'from_sources' => 'fromSources',
        'record_change_scope' => 'recordChangeScope',
        'source_options' => 'sourceOptions',
        'watch_data_in_field_ids' => 'watchDataInFieldIds',
        'watch_schemas_of_field_ids' => 'watchSchemasOfFieldIds'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'change_types' => 'setChangeTypes',
        'data_types' => 'setDataTypes',
        'from_sources' => 'setFromSources',
        'record_change_scope' => 'setRecordChangeScope',
        'source_options' => 'setSourceOptions',
        'watch_data_in_field_ids' => 'setWatchDataInFieldIds',
        'watch_schemas_of_field_ids' => 'setWatchSchemasOfFieldIds'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'change_types' => 'getChangeTypes',
        'data_types' => 'getDataTypes',
        'from_sources' => 'getFromSources',
        'record_change_scope' => 'getRecordChangeScope',
        'source_options' => 'getSourceOptions',
        'watch_data_in_field_ids' => 'getWatchDataInFieldIds',
        'watch_schemas_of_field_ids' => 'getWatchSchemasOfFieldIds'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const CHANGE_TYPES_ADD = 'add';
    public const CHANGE_TYPES_REMOVE = 'remove';
    public const CHANGE_TYPES_UPDATE = 'update';
    public const DATA_TYPES_TABLE_DATA = 'tableData';
    public const DATA_TYPES_TABLE_FIELDS = 'tableFields';
    public const DATA_TYPES_TABLE_METADATA = 'tableMetadata';
    public const FROM_SOURCES_CLIENT = 'client';
    public const FROM_SOURCES_PUBLIC_API = 'publicApi';
    public const FROM_SOURCES_FORM_SUBMISSION = 'formSubmission';
    public const FROM_SOURCES_FORM_PAGE_SUBMISSION = 'formPageSubmission';
    public const FROM_SOURCES_AUTOMATION = 'automation';
    public const FROM_SOURCES_SYSTEM = 'system';
    public const FROM_SOURCES_SYNC = 'sync';
    public const FROM_SOURCES_ANONYMOUS_USER = 'anonymousUser';
    public const FROM_SOURCES_UNKNOWN = 'unknown';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getChangeTypesAllowableValues()
    {
        return [
            self::CHANGE_TYPES_ADD,
            self::CHANGE_TYPES_REMOVE,
            self::CHANGE_TYPES_UPDATE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDataTypesAllowableValues()
    {
        return [
            self::DATA_TYPES_TABLE_DATA,
            self::DATA_TYPES_TABLE_FIELDS,
            self::DATA_TYPES_TABLE_METADATA,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFromSourcesAllowableValues()
    {
        return [
            self::FROM_SOURCES_CLIENT,
            self::FROM_SOURCES_PUBLIC_API,
            self::FROM_SOURCES_FORM_SUBMISSION,
            self::FROM_SOURCES_FORM_PAGE_SUBMISSION,
            self::FROM_SOURCES_AUTOMATION,
            self::FROM_SOURCES_SYSTEM,
            self::FROM_SOURCES_SYNC,
            self::FROM_SOURCES_ANONYMOUS_USER,
            self::FROM_SOURCES_UNKNOWN,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('change_types', $data ?? [], null);
        $this->setIfExists('data_types', $data ?? [], null);
        $this->setIfExists('from_sources', $data ?? [], null);
        $this->setIfExists('record_change_scope', $data ?? [], null);
        $this->setIfExists('source_options', $data ?? [], null);
        $this->setIfExists('watch_data_in_field_ids', $data ?? [], null);
        $this->setIfExists('watch_schemas_of_field_ids', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['data_types'] === null) {
            $invalidProperties[] = "'data_types' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets change_types
     *
     * @return string[]|null
     */
    public function getChangeTypes()
    {
        return $this->container['change_types'];
    }

    /**
     * Sets change_types
     *
     * @param string[]|null $change_types Only generate payloads that contain changes of these types.
     *
     * @return self
     */
    public function setChangeTypes($change_types)
    {
        if (is_null($change_types)) {
            throw new \InvalidArgumentException('non-nullable change_types cannot be null');
        }
        $allowedValues = $this->getChangeTypesAllowableValues();
        if (array_diff($change_types, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'change_types', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['change_types'] = $change_types;

        return $this;
    }

    /**
     * Gets data_types
     *
     * @return string[]
     */
    public function getDataTypes()
    {
        return $this->container['data_types'];
    }

    /**
     * Sets data_types
     *
     * @param string[] $data_types Only generate payloads that contain changes affecting objects of these types.  - `tableData`: record and cell value changes - `tableFields`: field changes - `tableMetadata`: table name and description changes
     *
     * @return self
     */
    public function setDataTypes($data_types)
    {
        if (is_null($data_types)) {
            throw new \InvalidArgumentException('non-nullable data_types cannot be null');
        }
        $allowedValues = $this->getDataTypesAllowableValues();
        if (array_diff($data_types, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'data_types', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['data_types'] = $data_types;

        return $this;
    }

    /**
     * Gets from_sources
     *
     * @return string[]|null
     */
    public function getFromSources()
    {
        return $this->container['from_sources'];
    }

    /**
     * Sets from_sources
     *
     * @param string[]|null $from_sources Only generate payloads for changes from these sources. If omitted, changes from all sources are reported.   - `client`: changes generated by a user through the web or mobile clients  - `publicApi`: changes generated through the Airtable API  - `formSubmission`: changes generated when a form _view_ is submitted  - `formPageSubmission`: changes generated when an _interface_ form builder page, form layout page, or record creation button page is submitted  - `automation`: changes generated through an automation action  - `system`: changes generated by system events, such as processing time function formulas  - `sync`: changes generated through Airtable Sync
     *
     * @return self
     */
    public function setFromSources($from_sources)
    {
        if (is_null($from_sources)) {
            throw new \InvalidArgumentException('non-nullable from_sources cannot be null');
        }
        $allowedValues = $this->getFromSourcesAllowableValues();
        if (array_diff($from_sources, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'from_sources', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['from_sources'] = $from_sources;

        return $this;
    }

    /**
     * Gets record_change_scope
     *
     * @return string|null
     */
    public function getRecordChangeScope()
    {
        return $this->container['record_change_scope'];
    }

    /**
     * Sets record_change_scope
     *
     * @param string|null $record_change_scope Only generate payloads for changes in the specified TableId or ViewId.  `Warning`: [Form view](https://support.airtable.com/v1/docs/form-view) and [List view](https://support.airtable.com/v1/docs/list-view) are currently not supported.
     *
     * @return self
     */
    public function setRecordChangeScope($record_change_scope)
    {
        if (is_null($record_change_scope)) {
            throw new \InvalidArgumentException('non-nullable record_change_scope cannot be null');
        }
        $this->container['record_change_scope'] = $record_change_scope;

        return $this;
    }

    /**
     * Gets source_options
     *
     * @return \Ez128\Airtable\Model\WebhooksSpecificationFiltersSourceOptions|null
     */
    public function getSourceOptions()
    {
        return $this->container['source_options'];
    }

    /**
     * Sets source_options
     *
     * @param \Ez128\Airtable\Model\WebhooksSpecificationFiltersSourceOptions|null $source_options source_options
     *
     * @return self
     */
    public function setSourceOptions($source_options)
    {
        if (is_null($source_options)) {
            throw new \InvalidArgumentException('non-nullable source_options cannot be null');
        }
        $this->container['source_options'] = $source_options;

        return $this;
    }

    /**
     * Gets watch_data_in_field_ids
     *
     * @return string[]|null
     */
    public function getWatchDataInFieldIds()
    {
        return $this->container['watch_data_in_field_ids'];
    }

    /**
     * Sets watch_data_in_field_ids
     *
     * @param string[]|null $watch_data_in_field_ids Only generate payloads for changes that modify values in cells in these fields. If omitted, all fields within the table/view/base are watched.  `Warning`: If fields are specified and one of the specified fields are deleted, the webhook will generate an error payload and the webhook will go into an error state and payloads will no longer be generated. More information about the error reponse is available in [Webhooks payload](/api/model/webhooks-payload).
     *
     * @return self
     */
    public function setWatchDataInFieldIds($watch_data_in_field_ids)
    {
        if (is_null($watch_data_in_field_ids)) {
            throw new \InvalidArgumentException('non-nullable watch_data_in_field_ids cannot be null');
        }
        $this->container['watch_data_in_field_ids'] = $watch_data_in_field_ids;

        return $this;
    }

    /**
     * Gets watch_schemas_of_field_ids
     *
     * @return string[]|null
     */
    public function getWatchSchemasOfFieldIds()
    {
        return $this->container['watch_schemas_of_field_ids'];
    }

    /**
     * Sets watch_schemas_of_field_ids
     *
     * @param string[]|null $watch_schemas_of_field_ids Only generate payloads for changes that modify the schemas of these fields. If omitted, schemas of all fields within the table/view/base are watched.  `Warning`: If fields are specified and one of the specified fields are deleted, the webhook will generate an error payload and the webhook will go into an error state and payloads will no longer be generated. More information about the error reponse is available in [Webhooks payload](/api/model/webhooks-payload).
     *
     * @return self
     */
    public function setWatchSchemasOfFieldIds($watch_schemas_of_field_ids)
    {
        if (is_null($watch_schemas_of_field_ids)) {
            throw new \InvalidArgumentException('non-nullable watch_schemas_of_field_ids cannot be null');
        }
        $this->container['watch_schemas_of_field_ids'] = $watch_schemas_of_field_ids;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


